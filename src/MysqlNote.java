public class MysqlNote{
    /*
    数据类型：
        整形：(tiny/small/mid/ /big)int  in(a)a为宽度，字节数
        浮点数：float(),double(）
        定点数：decimal（n,m）m为小数点后长度，浮点数也可这么用
        字符型：char（不可变，速度快）.varchar(占用空间小，可变) 创建时指定最大长度： varchar（5）
        二进制型：BLOB BINARY等，存储不同数量大小的二进制数据
        时间：datetime，timestamp(范围小，按时区)，date（日期）

     数据库：create/drop database name

     存储引擎：决定数据表的存储形式
     InnoDb:支持事务，并发，支持外键和行级锁，聚集索引（索引的逻辑顺序与物理存储顺序相同，通常索引为主键）auto-increment(必须为主剪，且值唯一)，插入速度慢，需要较大内存与空间(更新删除)
     MYISAM:不支持事务和并发，支持表级锁，非聚集索引（索引的逻辑顺序与物理存储顺序不同），但插入速度快，内存和空间需要小（插入查询）

     MEMORY: 数据都在内存中，速度快，但不安全，大小有限制。

     数据表：create table name(
             字段1 数据类型 [约束]；
             字段2 数据类型 [约束]；
             字段3 数据类型 [约束]
     );
     约束类型：主键约束 primary key(可以为多个字段)
               外键约束：forign key
               非空约束：not null
               唯一约束：unique
               默认：default

               项目中：用户ID为主键，身份证为唯一，数据上传频率默认约束（1小时5次），联系人的姓名非空约束，警报、联系人等数据表的
               外键对应用户的ID为外键约束等等


     索引：由数据表中一列或者多列组成，
           优点：提高查询和定位数据记录的速度，对于使用联合的查询，或者使用排序分组的插叙，可以提高查询的速度。（读）
           缺点：创建索引需要额外的时间和物理空间，且更新删除插入数据时，还需维护索引，降低数据的维护速度。（写）
           类型：
                普通索引：创建索引不加其他限制条件
                唯一索引：UNIQUE,该索引对应的字段值必须唯一，主键就是一种唯一索引
                全文索引：主要针对字符串类型数据（FULLTEXT），查询数据量大的字符窜类型时，使用全文索引较快
                单列索引：在表的单个字段建立索引，该索引只根据该字段进行索引
                多列索引：在表的多个字段建立索引，该索引根据多个字段进行索引。但是必须为查询条件使用了这些字段的第一个字段才起作用

           设计原则：尽量选择唯一索引，为查询多的字段建立索引，为经常需要联合，排序的字段建立索引
           创建索引
                    建表时建立：create table name(
                        ziudan1  shujuleiixng    [yueshu],
                        ziudan2  shujuleiixng    [yueshu],
                        [unique/fulltext] index/key [别名](字段  [ASC/DESC])
                    );
                    建立表后添加：
                        create [unique/fulletext]  index  索引名  on 表名  （字段 [ASC/DESC]）
                        alter table add index 索引名 (ziduan)
            删除索引： drop index  索引名 on tablename
            索引失效：
                    一些关键字：or，<>,not in ,is null,is not null
                    like查询以%开头
                    索引应用内部函数，索引字段进行了运算等
            用户的ID为索引，传感器类型作为索引

    视图：从数据表或其他视图中导出的虚拟表，数据库中只存放了视图的定义，并未存放视图的数据，数据还存放在原来数据表中，依赖
          于原来表的数据。
          优点：通过视图获得信息就是需要获得的信息，数据安全性（只能获取到视图提供的数据），不收非视图包含内容变化的影响
          create view 名称  as  select语句，限制内容
          与表的区别：视图不占实际内存，删除建立视图不会影响实际记录，视图可以对应一个或多个表。
          不能更新：创建视图时包含sum函数，分组，联合等操作。

     查询：
            group by 只会显示组内一条数据
            sort by
            group-contact(ziduan)
            in 集合
            between and 范围
            distinct 消除字段重复的内容
            limit 限制查询结果的个数
     连接查询：将两个或者两个以上的表按条件连接起来
               内连接，左右表满足条件的记录
               外连接，左连接、右连接
     子查询：将一个查询语句嵌套到另一个查询语句，内层查询语句的结果作为外层查询的内容
     联合查询：将多个select语句的查询结果合并到一起
               union :将所有结果合并起来，删除重复的记录
               union all:仅仅合并所有的结果

     存储过程与函数：在数据库中定义好的一些SQL语句的集合。可以通过直接调用这些存储过程或者函数来执行已经定义好的额SQL语句。
        优点：避免重复编写代码，存储过程和函数存储在服务器数据库，可以减少数据的通信量。
        区别：函数的参数均为输入，输出通过return返回，且只有一个输出
              存储过程的参数可以为    IN OUT INOUT三种，可以输出多个值，使用时需要通过call
        create procedure name ([IN/OUT/INOUT] 参数名1  参数类型[,参数2 参数类型])
                begin
                    sql语句
                end
        存储过程的调用：call

        create function name(参数名1  参数类型[,参数2 参数类型])
            return 返回类型
            begin
                sql语句
            end
         函数可以直接使用

         项目：1是显示用户各种状态（心率、坐姿、血压等）的最新数据，用存储过程的好处是可以同时有多个输出，获取多个状态数据
            2是插入用户的上传数据，频率一定，上传频繁

        数据库优化：
        show status like 'value';连接数目，增删改查的次数等
        从优化数据库的角度：选择字段的合适属性，将字段很长的表分解成多个表（有些字段的使用频率很低），增加中间表（经常查询多个表中的几个字段），

        从减少数据访问的角度：正确的使用索引，加快数据的查找；如果只需要访问表中几个字段，可以建立多字段的索引
                             优化子查询，子查询建立临时表后删除，使用连接替代子查询
         从返回更少数据角度：数据分页，只返回需要的数据
         从减少交互次数角度：批处理，使用存储过程等
         从数据库服务器的角度进行优化，等等。

        数据库的水平划分和垂直划分：
        垂直划分：把表按照功能（字段）划分到不同的数据表中，没有解决单表大数据量问题，用于读写分离场景
                项目中将节点与节点数据分离，因为节点数据写操作很多，节点只是包含节点名称、状态，上传频率等，这些为固定值
        水平划分：把表按照一定规则划分到不同的表中，表的结构不变。

        数据库的隔离级别：
        未提交读（）已提交读（脏读）可重复读（脏读，可重复读）可串行化（脏读，可重复读，幻读）Innodb标准：可重复读
        数据库的悲观锁和乐观锁：
        悲观：每次获取数据时假定会发生冲突，给数据加锁
        乐观锁：每次获取数据时假定不会发生冲突，只有在提交更新操作时判断在此期间是否已经被更新过。
            实现：数据版本记录机制，时间戳机制



        数据库的三范式：
                      一范式：数据表的列不可分割（用户地址：武昌区，具体地址）
                      二范式：满足一范式，数据表必须具有主键，且非主键的列完全依赖于主键（主键可能由多个字段组成，完全依赖代表
                      依赖于所有字段）
                      三范式：满足二范式，数据表非主键列必须直接依赖于主键，不能依赖传递，使数据表中的字段不能是其他数据表的非主键
                      字段，（外键的使用，以项目来说，节点数据表中包括节点名称、节点ID，节点状态，上传频率等信息，节点数据表里
                      只有节点ID这个属性，其他的时节点的值）














     */
}